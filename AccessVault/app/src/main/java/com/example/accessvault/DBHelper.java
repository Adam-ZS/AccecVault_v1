package com.example.accessvault;

import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;
import android.security.keystore.KeyGenParameterSpec;
import android.security.keystore.KeyProperties;
import android.util.Base64;
import android.util.Log;

import java.nio.charset.StandardCharsets;
import java.security.KeyStore;
import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.List;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;

public class DBHelper extends SQLiteOpenHelper {
    private static final String DATABASE_NAME = "accessvault.db";
    private static final int DATABASE_VERSION = 1;

    public static final String TABLE_CREDENTIALS = "credentials";
    public static final String COLUMN_ID = "id";
    public static final String COLUMN_SITE_NAME = "site_name";
    public static final String COLUMN_ENCRYPTED_DATA = "encrypted_data"; // Stores IV:encrypted(username:password)

    private static final String ANDROID_KEYSTORE = "AndroidKeyStore";
    private static final String KEY_ALIAS = "AccessVaultKey";
    private static final String AES_MODE = "AES/CBC/PKCS7Padding";
    private static final int IV_SIZE = 12; // For GCM, or 16 for CBC

    private static final String TAG = "DBHelper";

    public DBHelper(Context context) {
        super(context, DATABASE_NAME, null, DATABASE_VERSION);
        try {
            getOrCreateSecretKey(KEY_ALIAS); // Ensure key exists
        } catch (Exception e) {
            Log.e(TAG, "Keystore key initialization failed", e);
            // Handle this critical failure - app might not be usable
        }
    }

    @Override
    public void onCreate(SQLiteDatabase db) {
        String CREATE_TABLE = "CREATE TABLE " + TABLE_CREDENTIALS + "("
                + COLUMN_ID + " INTEGER PRIMARY KEY AUTOINCREMENT,"
                + COLUMN_SITE_NAME + " TEXT NOT NULL UNIQUE," // Site name should be unique
                + COLUMN_ENCRYPTED_DATA + " TEXT NOT NULL" + ")";
        db.execSQL(CREATE_TABLE);
    }

    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
        db.execSQL("DROP TABLE IF EXISTS " + TABLE_CREDENTIALS);
        onCreate(db);
    }

    private SecretKey getOrCreateSecretKey(String alias) throws Exception {
        KeyStore keyStore = KeyStore.getInstance(ANDROID_KEYSTORE);
        keyStore.load(null);

        if (!keyStore.containsAlias(alias)) {
            final KeyGenerator keyGenerator = KeyGenerator.getInstance(KeyProperties.KEY_ALGORITHM_AES, ANDROID_KEYSTORE);
            final KeyGenParameterSpec.Builder builder = new KeyGenParameterSpec.Builder(
                    alias,
                    KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)
                    .setBlockModes(KeyProperties.BLOCK_MODE_CBC) // Or KeyProperties.BLOCK_MODE_GCM
                    .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_PKCS7) // Or KeyProperties.ENCRYPTION_PADDING_NONE for GCM
                    .setRandomizedEncryptionRequired(true); // Good practice
            // setUserAuthenticationRequired(false) by default.
            // If you want the key to be usable only after biometric auth for each use:
            // .setUserAuthenticationRequired(true)
            // .setUserAuthenticationValidityDurationSeconds(AUTH_DURATION_SECONDS) // e.g., 30
            keyGenerator.init(builder.build());
            return keyGenerator.generateKey();
        }
        return (SecretKey) keyStore.getKey(alias, null);
    }


    private Cipher getCipher(int mode, byte[] iv) throws Exception {
        Cipher cipher = Cipher.getInstance(AES_MODE);
        SecretKey secretKey = getOrCreateSecretKey(KEY_ALIAS);
        if (mode == Cipher.ENCRYPT_MODE) {
            cipher.init(mode, secretKey, new SecureRandom()); // IV is generated by Cipher
        } else {
            cipher.init(mode, secretKey, new IvParameterSpec(iv));
        }
        return cipher;
    }


    public boolean addCredential(String siteName, String username, String password) {
        if (siteName == null || siteName.trim().isEmpty() ||
                username == null || username.trim().isEmpty() ||
                password == null || password.isEmpty()) {
            Log.e(TAG, "Site name, username, or password cannot be empty.");
            return false;
        }

        SQLiteDatabase db = this.getWritableDatabase();
        ContentValues values = new ContentValues();
        values.put(COLUMN_SITE_NAME, siteName.trim());

        try {
            String combinedData = username + ":" + password; // Simple combination
            Cipher cipher = getCipher(Cipher.ENCRYPT_MODE, null); // IV will be generated
            byte[] iv = cipher.getIV();
            byte[] encryptedData = cipher.doFinal(combinedData.getBytes(StandardCharsets.UTF_8));

            String ivString = Base64.encodeToString(iv, Base64.DEFAULT);
            String encryptedDataString = Base64.encodeToString(encryptedData, Base64.DEFAULT);

            values.put(COLUMN_ENCRYPTED_DATA, ivString + ":" + encryptedDataString);

            // Use insertWithOnConflict to handle unique constraint on site_name
            long result = db.insertWithOnConflict(TABLE_CREDENTIALS, null, values, SQLiteDatabase.CONFLICT_REPLACE);
            db.close();
            return result != -1;
        } catch (Exception e) {
            Log.e(TAG, "Error encrypting or adding credential for " + siteName, e);
            db.close();
            return false;
        }
    }

    public List<Credential> getAllCredentials() {
        List<Credential> credentialsList = new ArrayList<>();
        SQLiteDatabase db = this.getReadableDatabase();
        Cursor cursor = db.rawQuery("SELECT * FROM " + TABLE_CREDENTIALS, null);

        if (cursor.moveToFirst()) {
            do {
                try {
                    long id = cursor.getLong(cursor.getColumnIndexOrThrow(COLUMN_ID));
                    String siteName = cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_SITE_NAME));
                    String storedEncryptedString = cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_ENCRYPTED_DATA));

                    String[] parts = storedEncryptedString.split(":", 2);
                    if (parts.length != 2) {
                        Log.e(TAG, "Invalid stored encrypted data format for site: " + siteName);
                        continue;
                    }
                    byte[] iv = Base64.decode(parts[0], Base64.DEFAULT);
                    byte[] encryptedData = Base64.decode(parts[1], Base64.DEFAULT);

                    Cipher cipher = getCipher(Cipher.DECRYPT_MODE, iv);
                    byte[] decryptedDataBytes = cipher.doFinal(encryptedData);
                    String decryptedCombinedData = new String(decryptedDataBytes, StandardCharsets.UTF_8);

                    String[] userPassParts = decryptedCombinedData.split(":", 2);
                    if (userPassParts.length == 2) {
                        credentialsList.add(new Credential(id, siteName, userPassParts[0], userPassParts[1]));
                    } else if (userPassParts.length == 1 && decryptedCombinedData.endsWith(":")) { // Password was empty
                        credentialsList.add(new Credential(id, siteName, userPassParts[0], ""));
                    } else if (userPassParts.length == 1 && decryptedCombinedData.startsWith(":")) { // Username was empty
                        credentialsList.add(new Credential(id, siteName, "", userPassParts[0]));
                    } else { // Only username, no colon, password might be empty (adjust logic as needed)
                        credentialsList.add(new Credential(id, siteName, decryptedCombinedData, "")); // Assuming it's username only if no ':'
                        Log.w(TAG, "Decrypted data for " + siteName + " did not split into user/pass as expected: " + decryptedCombinedData);
                    }

                } catch (Exception e) {
                    Log.e(TAG, "Error decrypting or reading credential", e);
                }
            } while (cursor.moveToNext());
        }
        cursor.close();
        db.close();
        return credentialsList;
    }

    public Credential getCredentialBySiteName(String siteName) {
        SQLiteDatabase db = this.getReadableDatabase();
        Cursor cursor = db.query(TABLE_CREDENTIALS,
                new String[]{COLUMN_ID, COLUMN_SITE_NAME, COLUMN_ENCRYPTED_DATA},
                COLUMN_SITE_NAME + "=?",
                new String[]{siteName}, null, null, null, null);

        Credential credential = null;
        if (cursor != null && cursor.moveToFirst()) {
            try {
                long id = cursor.getLong(cursor.getColumnIndexOrThrow(COLUMN_ID));
                String storedEncryptedString = cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_ENCRYPTED_DATA));

                String[] parts = storedEncryptedString.split(":", 2);
                if (parts.length != 2) {
                    Log.e(TAG, "Invalid stored encrypted data format for site: " + siteName);
                    cursor.close();
                    db.close();
                    return null;
                }
                byte[] iv = Base64.decode(parts[0], Base64.DEFAULT);
                byte[] encryptedData = Base64.decode(parts[1], Base64.DEFAULT);

                Cipher cipher = getCipher(Cipher.DECRYPT_MODE, iv);
                byte[] decryptedDataBytes = cipher.doFinal(encryptedData);
                String decryptedCombinedData = new String(decryptedDataBytes, StandardCharsets.UTF_8);

                String[] userPassParts = decryptedCombinedData.split(":", 2);
                if (userPassParts.length == 2) {
                    credential = new Credential(id, siteName, userPassParts[0], userPassParts[1]);
                } else if (userPassParts.length == 1 && decryptedCombinedData.endsWith(":")) {
                    credential = new Credential(id, siteName, userPassParts[0], "");
                } else if (userPassParts.length == 1 && decryptedCombinedData.startsWith(":")) {
                    credential = new Credential(id, siteName, "", userPassParts[0]);
                } else {
                    Log.w(TAG, "Decrypted data for " + siteName + " did not split into user/pass for single fetch: " + decryptedCombinedData);
                    // Decide on fallback: maybe just the first part as username?
                    credential = new Credential(id, siteName, decryptedCombinedData, "");
                }

            } catch (Exception e) {
                Log.e(TAG, "Error decrypting credential for site: " + siteName, e);
            } finally {
                cursor.close();
            }
        }
        db.close();
        return credential;
    }

    public void deleteCredential(long id) {
        SQLiteDatabase db = this.getWritableDatabase();
        db.delete(TABLE_CREDENTIALS, COLUMN_ID + " = ?", new String[]{String.valueOf(id)});
        db.close();
    }
}